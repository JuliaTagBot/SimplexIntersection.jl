
"""
    IntersectingBoundaries()

Input arguments
---------------
Simplex1::Array{Float64, 2}            Contains the vertices of simplex 1. Each column is a vertex of simplex 1.
Simplex2::Array{Float64, 2}            Contains the vertices of simplex 2. Each column is a vertex of simplex 2.
Vert1Inside2::Array{Int-Float64, 2}    A (n+2)-by-M matrix. M depends on how many vertices lie outside or not. First row is integers corresponding to the indices of the vertices of 'Simplex1' lying inside 'Simplex2'. The remaining matrix contain the corresponding convex expansions in terms of the vertices of 'Simplex2'.
Vert2Inside1::Array{Int-Float64, 2}    A (n+2)-by-M matrix. M depends on how many vertices lie outside or not. First row is integers corresponding to the indices of the vertices of 'Simplex2' lying inside 'Simplex1'. The remaining matrix contain the corresponding convex expansions in terms of the vertices of 'Simplex1'.
Vert1Outside2::Array{Int-Float64, 2}   A (n+2)-by-M matrix, where M = n + 1 - 'numofTargetinSourceNotCom'. First row contains integers corresponding to the indices of the vertices of 'Simplex1' lying outside 'Simplex2' The remaining matrix contain the corresponding convex expansions in terms of the vertices of 'Simplex2'. In each column, at least one of the coefficients in the convex expansion must be negative (otherwise the point would be contained).
Vert2Outside1::Array{Int-Float64, 2}   A (n+2)-by-M matrix, where M = n + 1 - 'numofTargetinSourceNotCom'. First row contains integers corresponding to the indices of the vertices of 'Simplex2' lying outside 'Simplex1' The remaining matrix contain the corresponding convex expansions in terms of the vertices of 'Simplex1'. In each column, at least one of the coefficients in the convex expansion must be negative (otherwise the point would be contained).
Ncomm::Int                             Number of vertices that are shared by both simplices.
n::Int                                 The dimension of the space. Redundant. Loose it!
tolerance::Float64                     Any convex expansion coefficient less than 'tolerance' in absolute value is set to zero. Used to decide if a point belongs to a simplex.

Returns
-------
IntVert::Array{Float64, 2}            Contains all the intersecting points between all the boundaries of the simplices. Each row represents some intersecting point. Matrix of size D-by-N, where D = total number of intersecting points. Each row (NOT COLUMN!) is an intersecting point.
ConvexExpIntVert::Array{Float64, 2}   Dimension D-by-(2N + 2), where D = total number of intersecting points. (2N + 2) corresponds to the number of vertices in each simplex * 2. The first n+1 columns correspond to the convex expansion coefficients of the intersecting points in terms of the vertices generating 'Simplex1'. The remaining n+1 to (2N+2) columns correspond to the convex expansion coefficients of the intersecting points in terms of the vertices generating 'Simplex2'. The faces of each simplex are numbered according to the column labels.
"""
function IntersectingBoundaries(
    X, Y,
    Vert1Inside2, Vert2Inside1,
    Vert1Outside2, Vert2Outside1,
    Ncomm, n, tolerance)

    indices1inside2 = ifelse(Vert1Inside2 == 0, [], round.(Int64, Vert1Inside2[1, :]))
    indices2inside1 = ifelse(Vert2Inside1 == 0, [], round.(Int64, Vert2Inside1[1, :]))
    indices1outside2 = ifelse(Vert1Outside2 == 0, [], round.(Int64, Vert1Outside2[1, :]))
    indices2outside1 = ifelse(Vert2Outside1 == 0, [], round.(Int64, Vert2Outside1[1, :]))

    n1in2 = 0
    n2in1 = 0
    Beta1in2 = ConvexExp(Vert1Inside2, Vert1Outside2)


    Beta2in1 = ConvexExp(Vert2Inside1, Vert2Outside1)

    IndexVert1 = copy(transpose(indices1outside2))
    if size(Vert1Inside2, 1) > 1
        IndexVert1 = hcat(indices1inside2', IndexVert1)
        n1in2 = size(Vert1Inside2, 2)
    end

    IndexVert2 = copy(transpose(indices2outside1))
    if size(Vert2Inside1, 1) > 1
        IndexVert2 = [indices2inside1' IndexVert2]
        n2in1 = size(Vert2Inside1, 2)
    end

    Nin = sort([n1in2; n2in1])

    # The last one is excluded because it corresponds to the whole simplex
    Labels = transpose(collect(2 ^ Nin[1]:(2^(n +1 )-2)))

    #The one vertex boundaries correspond to the labels 2.^(0:n)
    #but since we discard all labels up to 2^(Nin(1))-1, then the one
    #vertex boundaries we still need to discard correspond to the labels
    #2.^(Nin(1):n), which correspond to the vertices with indices Nin(1)+1:n+1
    OneIndexLabels = transpose(2 .^ (Nin[1]:n)) -  2^(Nin[1]) + 1
    Labels[OneIndexLabels'] = zeros(size(OneIndexLabels))
    Labels = vec(Labels[find(Labels)])

# Now all the boundaries are generated by 2 or more vertices
# Notice that the first component of BoundaryBinaryLabels corresponds to the label 2^(Nin(1))+1

    BoundaryBinaryLabels = Binary(Labels, n)
    # contains 1 if the corresponding boundary is generated by 2 vertices and 0 otherwise
    NumberOfVertices = BoundaryBinaryLabels * ones(n + 1, 1)

    BoundaryBinaryLabels1 = BoundaryBinaryLabels
    NumberOfVertices1 = NumberOfVertices

    #For the boundaries 2 we still need to discard from BoundaryBinaryLabels the boundaries with labels up to 2^(Nin(2))-1
    #Actually, the first non trivial boundary of S2 in BoundaryBinaryLabels has label 2^(Nin(2))+1, since 2^(Nin(2)) corresponds to a 1-vertex boundary
    #(the Nin(2)+1 vertex)
    #within the labels 2^(Nin(1))+1:2^(Nin(2))+1 we find the 1-vertex boundaries corresponding to the vertices
    #with indices Nin(1)+2:Nin(2)+1, that is Nin(2)-Nin(1) 1-vertex boundaries, so that the first component of BoundaryBinaryLabels NOT
    #to be discarded is 2^(Nin(2))+1-(2^(Nin(2))+1)+1-(Nin(2)-Nin(1)),
    #where the last term comes from the fact that Nin(2)-Nin(1) of these labels have been
    #already discarded for corresponding to 1-vertex boundaries


    StartingIndexBound2 = 2^(Nin[2]) - 2^(Nin[1]) + 1 - (Nin[2] - Nin[1])

    BoundaryBinaryLabels2 = BoundaryBinaryLabels[StartingIndexBound2:size(BoundaryBinaryLabels, 1), :]


    NumberOfVertices2 = NumberOfVertices[StartingIndexBound2:size(BoundaryBinaryLabels, 1)]


    if n2in1 == Nin[1] && n1in2 > Nin[1]
        tmp1 = deepcopy(BoundaryBinaryLabels1)
        tmp2 = deepcopy(BoundaryBinaryLabels2)
        BoundaryBinaryLabels1 = tmp2
        BoundaryBinaryLabels2 = tmp1
        tmp3 = deepcopy(NumberOfVertices1)
        tmp4 = deepcopy(NumberOfVertices2)
        NumberOfVertices1 = tmp4
        NumberOfVertices2 = tmp3
    end
    # PAIRING OF BOUNDARIES
    # We adopt the representation 1\otimes 2
    # N1=size(NumberOfVertices1,2) and N2=size(NumberOfVertices2,2)
    # Pairing is an array of size [N1*N2 1]
    # a=1:N1*N2, a=(i1-1)*N2+i2  i1=1:N1, i2=1:N2
    # Pairing(a)=NumberOfVertices1(i1)+NumberOfVertices2(i2)
    NumberOfVertices1
    NumberOfVertices2
    N1 = size(NumberOfVertices1, 1)
    N2 = size(NumberOfVertices2, 1)
    NumberOfVertices1 = kron(NumberOfVertices1, ones(N2, 1))
    NumberOfVertices2 = kron(ones(N1, 1), NumberOfVertices2)
    BoundaryBinaryLabels1 = kron(BoundaryBinaryLabels1, ones(N2, 1))
    BoundaryBinaryLabels2 = kron(ones(N1, 1), BoundaryBinaryLabels2)

    # Total number of vertices of each pair of boundaries
    # Aux=heaviside(heaviside(n+2-Aux)-0.3);
    total = NumberOfVertices1 + NumberOfVertices2

    # Contains 1 if the total number of vertices for the corresponding pair of
    # boundaries is less than or equal to n+2, 0 otherwise
    Aux = heaviside0(n + 2 - total)

    # Contains the indices of the pairs of boundaries
    # with total number of vertices less than or equal to n+2
    Pairing = find(Aux .* collect(1:(N1 * N2)))

    BoundaryBinaryLabels1 = BoundaryBinaryLabels1[Pairing, :]
    BoundaryBinaryLabels2 = BoundaryBinaryLabels2[Pairing, :]

    if Ncomm > 0
        #Each row contains, 0,1 or 2
        #If there is any vertex shared by the boundaries, Aux will have a 2
        # somewhere in the row corresponding to the index of the pair of
        #boundaries in question
        Aux = BoundaryBinaryLabels1[:, 1:Ncomm] + BoundaryBinaryLabels2[:, 1:Ncomm]

        # Find maximum value of each row
        maxes = zeros(size(Aux, 1))
        for i=1:size(Aux, 1)
            maxes[i] = maximum(Aux[i, :])
        end
        maxes

        # Sets any 2 to 0 and the rest to 1
        Aux = heaviside(1.5 - maxes)

        # Contains the indices in the vector 1:size(Pairing,1) that correspond
        # to indices of pairs of boundaries with no shared vertices
        Aux = find(Aux .* collect(1:size(Aux, 1)))

        BoundaryBinaryLabels1 = BoundaryBinaryLabels1[Aux, :]
        BoundaryBinaryLabels2 = BoundaryBinaryLabels2[Aux, :]
    end

    IntVert, ConvexExpIntVert = BoundaryxBoundary(X,Y,BoundaryBinaryLabels1,BoundaryBinaryLabels2,IndexVert1,IndexVert2,Beta1in2,Beta2in1,tolerance)

    return IntVert, ConvexExpIntVert
end
