
"""
IntersectingBoundaries()

Returns
-------
IntVert::Array{Float64, 2}            Contains all the intersecting points between all the boundaries of the simplices. Each row represents some intersecting point. Matrix of size D-by-N, where D = total number of intersecting points. Each row (NOT COLUMN!) is an intersecting point.
ConvexExpIntVert::Array{Float64, 2}   Dimension D-by-(2N + 2), where D = total number of intersecting points. (2N + 2) corresponds to the number of vertices in each simplex * 2. The first n+1 columns correspond to the convex expansion coefficients of the intersecting points in terms of the vertices generating 'Simplex1'. The remaining n+1 to (2N+2) columns correspond to the convex expansion coefficients of the intersecting points in terms of the vertices generating 'Simplex2'. The faces of each simplex are numbered according to the column labels.
"""
function IntersectionOfBoundaries(
    Simplex1, Simplex2,
    convexexp1in2, convexexp2in1,
    ordered_vertices1, ordered_vertices2,
    numof1in2, numof2in1,
    Ncomm,
    tolerance)

    n::Int = size(Simplex1, 1)
    # size(Simplex1), size(Simplex2)
    IntVert = Vector{Float64}(0)
    ConvexExpIntVert = Vector{Float64}(0)
    Z = zeros(Float64,2*n+2,1)

    if (numof1in2 <= numof2in1)

        Nin = [numof1in2; numof2in1]

        # The last one is excluded because it corresponds to the whole simplex
        Labels = transpose(collect(2 ^ Nin[1]:(2^(n +1 )-2)))

        #The one vertex boundaries correspond to the labels 2.^(0:n)
        #but since we discard all labels up to 2^(Nin(1))-1, then the one
        #vertex boundaries we still need to discard correspond to the labels
        #2.^(Nin(1):n), which correspond to the vertices with indices Nin(1)+1:n+1
        OneIndexLabels = transpose(2 .^ (Nin[1]:n)) -  2^(Nin[1]) + 1
        Labels[OneIndexLabels'] = zeros(size(OneIndexLabels))
        Labels = vec(Labels[find(Labels)])

        # Now all the boundaries are generated by 2 or more vertices
        # Notice that the first component of BoundaryBinaryLabels corresponds to the label 2^(Nin(1))+1

        BoundaryBinaryLabels1 = Binary(Labels, n)
        # contains 1 if the corresponding boundary is generated by 2 vertices and 0 otherwise

        #For the boundaries 2 we still need to discard from BoundaryBinaryLabels the boundaries with labels up to 2^(Nin(2))-1
        #Actually, the first non trivial boundary of S2 in BoundaryBinaryLabels has label 2^(Nin(2))+1, since 2^(Nin(2)) corresponds to a 1-vertex boundary
        #(the Nin(2)+1 vertex)
        #within the labels 2^(Nin(1))+1:2^(Nin(2))+1 we find the 1-vertex boundaries corresponding to the vertices
        #with indices Nin(1)+2:Nin(2)+1, that is Nin(2)-Nin(1) 1-vertex boundaries, so that the first component of BoundaryBinaryLabels NOT
        #to be discarded is 2^(Nin(2))+1-(2^(Nin(2))+1)+1-(Nin(2)-Nin(1)),
        #where the last term comes from the fact that Nin(2)-Nin(1) of these labels have been
        #already discarded for corresponding to 1-vertex boundaries


        StartingIndexBound2 = 2^(Nin[2]) - 2^(Nin[1]) + 1 - (Nin[2] - Nin[1])

        #BoundaryBinaryLabels2 = BoundaryBinaryLabels1[StartingIndexBound2:size(BoundaryBinaryLabels1, 1), :]
        BoundaryBinaryLabels2 = view(BoundaryBinaryLabels1, StartingIndexBound2:size(BoundaryBinaryLabels1, 1), :)
    else
        Nin = [numof2in1; numof1in2]

        # The last one is excluded because it corresponds to the whole simplex
        Labels = transpose(collect(2 ^ Nin[1]:(2^(n +1 )-2)))

        #The one vertex boundaries correspond to the labels 2.^(0:n)
        #but since we discard all labels up to 2^(Nin(1))-1, then the one
        #vertex boundaries we still need to discard correspond to the labels
        #2.^(Nin(1):n), which correspond to the vertices with indices Nin(1)+1:n+1
        OneIndexLabels = transpose(2 .^ (Nin[1]:n)) -  2^(Nin[1]) + 1
        Labels[OneIndexLabels'] = zeros(size(OneIndexLabels))
        Labels = vec(Labels[find(Labels)])

        # Now all the boundaries are generated by 2 or more vertices
        # Notice that the first component of BoundaryBinaryLabels corresponds to the label 2^(Nin(1))+1

        BoundaryBinaryLabels2 = Binary(Labels, n)
        # contains 1 if the corresponding boundary is generated by 2 vertices and 0 otherwise

        #For the boundaries 2 we still need to discard from BoundaryBinaryLabels the boundaries with labels up to 2^(Nin(2))-1
        #Actually, the first non trivial boundary of S2 in BoundaryBinaryLabels has label 2^(Nin(2))+1, since 2^(Nin(2)) corresponds to a 1-vertex boundary
        #(the Nin(2)+1 vertex)
        #within the labels 2^(Nin(1))+1:2^(Nin(2))+1 we find the 1-vertex boundaries corresponding to the vertices
        #with indices Nin(1)+2:Nin(2)+1, that is Nin(2)-Nin(1) 1-vertex boundaries, so that the first component of BoundaryBinaryLabels NOT
        #to be discarded is 2^(Nin(2))+1-(2^(Nin(2))+1)+1-(Nin(2)-Nin(1)),
        #where the last term comes from the fact that Nin(2)-Nin(1) of these labels have been
        #already discarded for corresponding to 1-vertex boundaries


        StartingIndexBound1 = 2^(Nin[2]) - 2^(Nin[1]) + 1 - (Nin[2] - Nin[1])

        #BoundaryBinaryLabels1 = BoundaryBinaryLabels1[StartingIndexBound1:size(BoundaryBinaryLabels2, 1), :]
        BoundaryBinaryLabels1 = view(BoundaryBinaryLabels2, StartingIndexBound1:size(BoundaryBinaryLabels2, 1), :)
    end

    N = size(BoundaryBinaryLabels1,1)*size(BoundaryBinaryLabels2,1)
    #N1 = size(BoundaryBinaryLabels1,1)
    N2 = size(BoundaryBinaryLabels2,1)

    Indices = 1:n+1

    for i = 1:N
        #i = (index1-1)*N2 + index2
        #index1 \in {1,...,N1}
        #index2 \in {1,...,N2}
        index1 = ceil(Int,i/N2)
        index2 = i-(index1-1)*N2

        #b1 = BoundaryBinaryLabels1[index1,:]
        #b2 = BoundaryBinaryLabels2[index2,:]

        #b1 and b2 are column vectors!!
        b1 = view(BoundaryBinaryLabels1,index1,:)
        b2 = view(BoundaryBinaryLabels2,index2,:)

        num_vert = sum(b1 + b2) # total number of vertices in both boundaries (including repeatitions)
        no_common_vert = true
        #@show num_vert,size(num_vert)
        #b1[1:Ncomm] + b2[1:Ncomm]   contains, 0,1 or 2
        #If there is any vertex shared by the boundaries, a 2 will appear somewhere
        if Ncomm > 0

            no_common_vert = (maximum(b1[1:Ncomm] + b2[1:Ncomm])<2)
        end

        if num_vert <= n+2 && no_common_vert
            dim1 = sum(b1)
            dim2 = sum(b2)
            if (dim1 >= dim2)
                r = dim1
                s = dim2
                TargetVertices = view(Simplex2,:,:)
                # ReferenceBoundary and TargetBoundary are colummn vectors!!
                ReferenceBoundary = view(ordered_vertices1, Indices[find(b1)])
                TargetBoundary = view(ordered_vertices2, Indices[find(b2)])

                #ExtraIndices = Complementary(ReferenceBoundary,n+1)
                beta = view(convexexp2in1, :, :)
                Gamma = view(convexexp2in1, setdiff(1:n+1,ReferenceBoundary), TargetBoundary)
                Rank= rank(Gamma)
                Rank0 = rank([Gamma;ones(1,s)])
                no_vanishing_column = minimum(maximum(abs.(Gamma),1))

                Switch = 0


            else
                s = dim1
                r = dim2
                TargetVertices = view(Simplex1,:,:)
                # ReferenceBoundary and TargetBoundary are colummn vectors!!
                ReferenceBoundary = view(ordered_vertices2, Indices[find(b2)])
                TargetBoundary = view(ordered_vertices1, Indices[find(b1)])

                #ExtraIndices = Complementary(ReferenceBoundary,n+1)
                beta = view(convexexp1in2, :, :)
                Gamma = view(convexexp1in2, setdiff(1:n+1,ReferenceBoundary), TargetBoundary)
                Rank= rank(Gamma)
                Rank0 = rank([Gamma;ones(1,s)])
                no_vanishing_column = minimum(maximum(abs.(Gamma),1))

                Switch = 1

            end

            if Rank0-Rank == 1 && Rank == s-1 && no_vanishing_column > 0

                lambda = QR(Gamma,tolerance)
                #Alpha=zeros(r,s);
                #Alpha(2:r,:)=beta(ReferenceBoundary(2:r),TargetBoundary);
                #Alpha(1,:)=1-ones(1,r-1)*Alpha(2:r,:);

                alpha = [1 - ones(Int,1,r-1)*view(beta,ReferenceBoundary[2:r],TargetBoundary) ; view(beta,ReferenceBoundary[2:r],TargetBoundary)]*lambda
                #alpha=alpha.*Heaviside(abs(alpha)-tolerance);
                alpha[abs.(alpha) .<= tolerance] = 0 #alpha.*logical(abs(alpha)>tolerance)
                #aux=min(minimum(alpha), minimum(lambda))
                #Aux=size(nonzeros(alpha),1);
                #Aux=sum(find(alpha))
                #if some of these coefficients are negative the boundaries simply do
                #not intersect.
                #if some are zero, then the boundaries are not minimal and the intersecting point has already been
                #computed or will be computed as the intersection of minimal
                #boundaries.
                #This also rules out duplication of points


                if min(minimum(alpha), minimum(lambda)) > 0 && sum(find(alpha)) > 1
                    # Filtering out non minimal boundaries
                    #@show lambda
                    #@show alpha
                    #@show TargetVertices
                    NewPoint = view(TargetVertices,:,TargetBoundary)*lambda
                    #@show NewPoint
                    append!(IntVert,NewPoint)
                    Z .= 0

                    if Switch == 0
                        #@show typeof(ReferenceBoundary)

                        Z[ReferenceBoundary] .= view(alpha,:)
                        Z[TargetBoundary .+ (n + 1)] .= view(lambda,:)
                        #Aux[vcat(ReferenceBoundary, TargetBoundary + n + 1)] = hcat(alpha, lambda)
                    else
                        Z[ReferenceBoundary .+ (n + 1)] .= view(alpha,:)
                        Z[TargetBoundary] .= view(lambda,:)
                    end

                    append!(ConvexExpIntVert,Z)

                    #[IntVert,ConvexExpIntVert] = ConvexExpAndIntVert(IntVert,NewPoint,transpose(alpha),transpose(lambda),ReferenceBoundary,TargetBoundary,Switch,ConvexExpIntVert);

                end

            end
        end
    end


    return reshape(IntVert, n, div(length(IntVert), n)).', reshape(ConvexExpIntVert, 2*n+2, div(length(ConvexExpIntVert), 2*n+2)).'
end
